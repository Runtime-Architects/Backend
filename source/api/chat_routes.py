"""
chat_routes.py

This module contains FastAPI Routes for Chat Functionality
"""

import logging
import os
import sys

from fastapi import APIRouter, Depends, HTTPException, Request
from fastapi.responses import FileResponse, StreamingResponse

from api.api_models import APIResponse, MessageResponse, QuestionRequest
from api.auth_routes import get_current_user
from api.autogen_service import run_autogen_task, run_autogen_task_streaming
from api.models import User
from api.streamer import StreamEventManager


# Logging Config
logging.basicConfig(
    level=logging.INFO,
    stream=sys.stdout,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
)

logger = logging.getLogger(__name__)
router = APIRouter(tags=["chat"])


@router.post("/ask", response_model=APIResponse)
async def ask_endpoint(request: QuestionRequest):
    """Asynchronously handles a question request and returns a response.

    This function receives a `QuestionRequest`, processes the question using an
    autogenerated task, and returns an `APIResponse` containing the result. It logs
    the received question and any unexpected errors that occur during processing.

    Args:
        request (QuestionRequest): The request object containing the question to be processed.

    Returns:
        APIResponse: A response object indicating the success status and the content
        generated by the assistant.

    Raises:
        HTTPException: If an unexpected error occurs during processing, a 500 status
        HTTPException is raised.
    """
    try:
        logger.info(f"Received question: {request.question[:100]}...")

        # Run the AutoGen task
        response_content = await run_autogen_task(request.question)

        # Return the response in the expected format
        return APIResponse(
            status="Success",
            message=MessageResponse(role="assistant", content=response_content),
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Unexpected error in ask endpoint: {str(e)}")
        raise HTTPException(
            status_code=500, detail=f"An unexpected error occurred: {str(e)}"
        )


@router.post("/ask-stream")
async def ask_stream_endpoint(
    request_body: QuestionRequest,
    request: Request,
    current_user: User = Depends(get_current_user),
):
    """Asynchronously handles a streaming request for a question and returns a streaming response. Requires Auth.

    Args:
        request_body (QuestionRequest): The request body containing the question and conversation ID.
        request (Request): The HTTP request object.
        current_user (User, optional): The current authenticated user. Defaults to the result of `get_current_user`.

    Returns:
        StreamingResponse: A streaming response that yields chunks of data as they are generated.

    Raises:
        Any exceptions raised during the processing of the request will be propagated to the caller.
    """
    team_flow_factory = request.app.state.agent_factory
    team_flow = await team_flow_factory()

    async def generate_stream():
        event_manager = StreamEventManager()
        async for chunk in run_autogen_task_streaming(
            event_manager,
            request_body.question,
            current_user.id,
            request_body.conversation_id,
            team_flow,
        ):
            yield chunk

    return StreamingResponse(
        generate_stream(),
        media_type="text/event-stream",
        headers={"Cache-Control": "no-cache", "Connection": "keep-alive"},
    )


@router.get("/images/{image_name}")
async def get_image(image_name: str):
    """Retrieve an image file from the specified directory.

    This asynchronous function checks if the requested image exists in the
    'plots' directory and returns it as a file response. If the image path
    is invalid or the image does not exist, it raises an HTTPException.

    Args:
        image_name (str): The name of the image file to retrieve.

    Raises:
        HTTPException:
            - 400: If the image path is invalid (i.e., it does not start with
              the base directory).
            - 404: If the image file does not exist.

    Returns:
        FileResponse: A response containing the image file with the media type
        set to 'image/png'.
    """
    base_dir = os.path.abspath("plots")
    image_path = os.path.normpath(os.path.join(base_dir, image_name))
    if not image_path.startswith(base_dir):
        raise HTTPException(status_code=400, detail="Invalid image path")
    if not os.path.exists(image_path):
        raise HTTPException(status_code=404, detail="Image not found")
    return FileResponse(image_path, media_type="image/png", filename=image_name)


@router.post("/conversations/{conversation_id}/messages")
async def add_message_to_conversation(
    conversation_id: int,
    request_body: QuestionRequest,
    request: Request,
    current_user: User = Depends(get_current_user),
):
    """Adds a message to a conversation and streams the response.

    This asynchronous function retrieves a conversation by its ID and the current user's ID, then generates a streaming response for the provided question. If the conversation is not found, it raises a 404 HTTP exception.

    Args:
        conversation_id (int): The ID of the conversation to which the message will be added.
        request_body (QuestionRequest): The request body containing the question to be added to the conversation.
        request (Request): The HTTP request object.
        current_user (User, optional): The current user making the request. Defaults to the result of `get_current_user`.

    Returns:
        StreamingResponse: A streaming response that yields chunks of the generated message.

    Raises:
        HTTPException: If the conversation is not found, a 404 error is raised.
    """
    from sqlmodel import Session
    from api.db import get_session
    from api.models import Conversation

    # Verify conversation ownership
    session = next(get_session())

    conversation = (
        session.query(Conversation)
        .filter(
            Conversation.id == conversation_id, Conversation.user_id == current_user.id
        )
        .first()
    )
    session.close()

    if not conversation:
        raise HTTPException(status_code=404, detail="Conversation not found")

    team_flow_factory = request.app.state.agent_factory
    team_flow = await team_flow_factory()

    async def generate_stream():
        event_manager = StreamEventManager()
        async for chunk in run_autogen_task_streaming(
            event_manager,
            request_body.question,
            current_user.id,
            conversation_id,
            team_flow,
        ):
            yield chunk

    return StreamingResponse(
        generate_stream(),
        media_type="text/event-stream",
        headers={"Cache-Control": "no-cache", "Connection": "keep-alive"},
    )
